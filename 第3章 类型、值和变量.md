# 第3章 类型、值和变量

JavaScript的数据类型分为两类：原始类型（primitive type）和对象类型（object type）。

5种原始类型：数字、字符串、布尔值、null和undefined。除此之外的都是对象类型。

* 普通的JavaScript对象是“命名值”的无序集合。
* 带编号的值的有序集合：数组
* 一种特殊对象——函数。函数是具有与它相关联的可执行代码的对象

JavaScript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收（garbage collection）。这意味着程序可以按需创建对象，
程序员则不必担心这些对象的销毁和内存回收。当不再有任何引用指向一个对象，解释器就会知道这个对象没用了，然后自动回收它所
占用的内存资源。

* 可以拥有方法的类型和不能拥有方法的类型（null和undefined）
* 可变类型和不可变类型（数字、布尔值、null、undefined和字符串）

JavaScript变量是无类型的。

## 3.1 数字

和其他编程语言不同，JavaScript不区分整数值和浮点数值。JavaScript中的所有数字均用浮点数值表示。

### 3.1.1 整形直接量

十进制：

    0
    3
    100000

十六进制：

    0xff        // 255
    0xCAFE911   // 212855057

八进制：

    0377        // 255

<b>需要注意的是：</b>ECMAScript标准不支持八进制直接量，但JavaScript的某些实现可以允许采用八进制形式表示整数。由于某些
JavaScript的实现支持八进制直接量，而有些不支持，因此最好不要使用以0为前缀的整形直接量，毕竟我们也无法得知当前
JavaScript的实现是否支持八进制的解析。在ECMAScript6的严格模式下，八进制直接量是明令禁止的。

### 3.1.2 浮点型直接量

* 实数写法：整数部分 + 小数点 +　小数部分
* 指数记数法：实数 + 字母e（或E） + 正负号　＋ 整形的指数

    3.14
    2345.789
    .3333333
    6.02e23
    1.478223E-32

### 3.1.3 JavaScript中的算术运算

JavaScript的算术运算在溢出（overflow）、下溢（underflow）或被0整除时不会报错。当数字运算结果超过了JavaScript所能表示的
数字上限（溢出），结果为一个特殊的无穷大值，在JavaScript中以Infinity表示。同样地，当负数的值超过了JavaScript所能表示的
负数范围，结果为负无穷大，在JavaScript中以-Infinity表示。

### 3.2.4 模式匹配

    /^HTML/                         // 匹配以HTML开始的字符串
    /\bjavascript\b/                // 匹配单词"javascript"，忽略大小写

    var text = "testing: 1, 2, 3";  // 文本示例
    var pattern = /\d+/g            // 匹配所有包含一个或多个数字的实例
    pattern.test(text)              // => true:匹配成功
    text.search(pattern)            // => 9:首次匹配成功的位置
    text.match(pattern)             // => ["1", "2", "3"]:所有匹配组成的数组
    text.replace(pattern, "#")      // => "testing: #, #, #"
    text.split(/\D+/)               // => ["", "1", "2", "3"]: 用非数字字符截取字符串

## 3.3 布尔值

下面这些值会被转换成false：

    undefined
    null
    0
    -0
    NaN
    ""

所有其他值，包括所有对象（数组）都会转换成true。

## 3.6 包装对象

null和undefined没有包装对象：访问它们的属性会造成一个类型错误。

    var s = "test";     // 创建一个字符串
    s.len = 4;          // 给它设置一个属性
    var t = s.len;      // 查询这个属性

当运行这段代码时，t的值是undefined。第二行代码创建一个临时字符串对象，并给其len属性赋值为4，随即销毁这个对象。第三行
通过原始的（没有被修改过）字符串值创建一个新字符串对象，尝试读取其len属性，这个属性自然不存在，表达式求值结果为undefined。
这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现地像对象一样。但如果你试图给其属性赋值，则会忽略
这个操作：修改只是发生在临时对象上，而这个临时对象并未继续保留下来。

### 3.8.3 对象转换为原始值

toString()和valueOf方法，就可以做到对象到字符串和对象到数字的转换了。

## 3.9 变量声明

在JavaScript程序中，使用一个变量之前应当先声明。变量是使用关键字var来声明的，如下所示：

    var i;
    var sum;

如果你试图读取一个没有声明的变量的值，JavaScript会报错。在ECMAScript5严格模式中，给一个没有声明的变量赋值也会报错。
然而从历史上讲，在非严格模式下，如果给一个未声明的变量赋值，JavaScript实际上会给全局对象创建一个同名属性，并且它工作起来
像一个正确声明的全局变量。

    (function() {
        a = 100;
    }());

上述代码可以正确运行。如果加上<code>"use strict";</code>，就会报错，<code>Uncaught ReferenceError: a is not defined</code>

    "use strict";
    (function() {
        a = 100;
    }());

JavaScript中没有块级作用域，取而代之地使用了函数作用域（function scope）：变量在声明它们的函数体以及这个函数体嵌套的
任意函数体内都是有定义的。

JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至可以使用。
JavaScript的这个特性被非正式地称为声明提前，及JavaScript函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部。

在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的
编程习惯。由于JavaScript没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。
这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。


























